window.requestAnimFrame = (function() {
    return window.requestAnimationFrame || function(callback) {
        window.setTimeout(callback, 1000 / 60);
    };
})();

$(function() {
    const canvas = document.getElementById('startrack');
    const ctx = canvas.getContext('2d');
    
    // 强制使用 window 的宽高，不依赖 CSS 渲染状态
    let cw = window.innerWidth;
    let ch = window.innerHeight;
    canvas.width = cw;
    canvas.height = ch;
    
    // 监听窗口大小变化
    window.addEventListener('resize', function() {
        cw = window.innerWidth;
        ch = window.innerHeight;
        canvas.width = cw;
        canvas.height = ch;
    });

    let mx = 0, my = 0;
    
    // 鼠标交互：视差效果 + 卡片 3D 旋转
    document.addEventListener('mousemove', (e) => {
        // 计算鼠标相对于中心的归一化位置 (-0.5 到 0.5)
        mx = (e.clientX - cw / 2) / cw;
        my = (e.clientY - ch / 2) / ch;
        
        const card = document.getElementById('tilt-card');
        if(card) {
            // 限制旋转角度，避免过度翻转
            card.style.transform = `perspective(1000px) rotateX(${-my * 15}deg) rotateY(${mx * 15}deg)`;
        }
    });

    // 鼠标移出复位
    document.addEventListener('mouseleave', () => {
        const card = document.getElementById('tilt-card');
        if(card) card.style.transform = `perspective(1000px) rotateX(0) rotateY(0)`;
    });

    // --- 粒子系统 ---
    
    class Star {
        constructor() {
            this.reset();
        }
        reset() {
            this.r = Math.random() * Math.max(cw, ch) * 0.7 + 60; // 避免过于聚集中心
            this.angle = Math.random() * Math.PI * 2;
            // 速度与半径成反比（开普勒模拟）
            this.omega = (Math.random() * 0.5 + 0.5) * 600 / Math.pow(this.r, 1.4); 
            this.size = Math.random() * 2 + 0.5;
            // 颜色动态生成：越近越蓝，越远越红
            const t = Math.min(1, (this.r - 60) / (Math.max(cw, ch) * 0.5));
            const r = Math.floor(150 + 100 * t);
            const g = Math.floor(180 + 50 * t);
            const b = 255;
            this.color = `rgba(${r},${g},${b},${Math.random()*0.6+0.4})`;
        }
        update() {
            this.angle += this.omega * 0.01; // 调整速度系数
            if(this.r < 0) this.reset();
        }
        draw() {
            const x = cw / 2 + Math.cos(this.angle) * this.r - mx * 30; // 增加视差移动
            const y = ch / 2 + Math.sin(this.angle) * this.r - my * 30;
            ctx.beginPath();
            ctx.arc(x, y, this.size, 0, Math.PI * 2);
            ctx.fillStyle = this.color;
            ctx.fill();
        }
    }

    class Particle {
        constructor(x, y) {
            this.x = x;
            this.y = y;
            const a = Math.random() * Math.PI * 2;
            const s = Math.random() * 4 + 1;
            this.vx = Math.cos(a) * s;
            this.vy = Math.sin(a) * s;
            this.life = 1;
            this.hue = Math.random() * 60 + 280; // 紫粉色系
        }
        update() {
            this.x += this.vx;
            this.y += this.vy;
            this.vy += 0.15; // 重力
            this.life -= 0.02;
        }
        draw() {
            ctx.globalAlpha = this.life;
            ctx.fillStyle = `hsla(${this.hue}, 80%, 70%, 1)`;
            ctx.beginPath();
            ctx.arc(this.x, this.y, 2.5, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1;
        }
    }

    const stars = [];
    const particles = [];
    for(let i=0; i<1200; i++) stars.push(new Star());

    // 点击生成爆炸粒子
    document.addEventListener('mousedown', function(e) {
        for(let i=0; i<15; i++) {
            particles.push(new Particle(e.clientX, e.clientY));
        }
    });

    function loop() {
        // 拖尾效果
        ctx.fillStyle = 'rgba(9, 10, 15, 0.2)';
        ctx.fillRect(0, 0, cw, ch);

        ctx.globalCompositeOperation = 'lighter';
        
        stars.forEach(s => {
            s.update();
            s.draw();
        });

        for(let i=particles.length-1; i>=0; i--) {
            particles[i].update();
            particles[i].draw();
            if(particles[i].life <= 0) particles.splice(i, 1);
        }

        ctx.globalCompositeOperation = 'source-over';
        requestAnimFrame(loop);
    }
    
    loop();
});
