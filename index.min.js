$(function () {
    const canvas = document.getElementById('startrack');
    const ctx = canvas.getContext('2d');
    
    let width, height;
    let particles = [];
    
    // 核心参数配置
    const config = {
        particleCount: 3000,    // 粒子数量，追求极致画面设为 3000-5000
        baseRadius: 150,        // 土星本体半径
        ringInner: 220,         // 光环内径
        ringOuter: 450,         // 光环外径
        focalLength: 400,       // 摄像机焦距
        baseZoom: 1,            // 基础缩放
        chaosThreshold: 2.8,    // 触发混沌炸裂的缩放阈值
        colorBase: { r: 255, g: 200, b: 245 } // 樱花粉基调
    };

    // 状态管理
    const state = {
        mouseX: 0,
        mouseY: 0,
        rotationX: 0.5,         // 初始倾角
        rotationY: 0,
        zoom: 1,
        hoverTarget: null,      // 当前鼠标悬停的DOM元素的目标中心 {x, y, radius}
        chaosMode: false        // 是否处于混沌状态
    };

    // 交互元素选择器
    const interactiveElements = $('.name, .btn, .avatar-img');

    // 初始化 Canvas
    function resize() {
        width = canvas.width = window.innerWidth;
        height = canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    // 3D 粒子类
    class Particle {
        constructor(type) {
            this.type = type; // 'planet' 或 'ring'
            this.reset();
        }

        reset() {
            // 依据类型生成位置
            if (this.type === 'planet') {
                // 球体生成算法
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos((Math.random() * 2) - 1);
                const r = Math.cbrt(Math.random()) * config.baseRadius; // cbrt使分布均匀
                
                this.x = r * Math.sin(phi) * Math.cos(theta);
                this.y = r * Math.sin(phi) * Math.sin(theta);
                this.z = r * Math.cos(phi);
                this.baseSpeed = 0.005; // 球体自转速度
            } else {
                // 光环生成算法 (扁平圆盘)
                const angle = Math.random() * Math.PI * 2;
                const dist = config.ringInner + Math.random() * (config.ringOuter - config.ringInner);
                
                this.x = Math.cos(angle) * dist;
                this.y = (Math.random() - 0.5) * 10; // 光环厚度微扰
                this.z = Math.sin(angle) * dist;
                
                // 开普勒第三定律：速度与距离平方根成反比 v ∝ 1/sqrt(r)
                this.baseSpeed = 8 / Math.sqrt(dist); 
                this.orbitRadius = dist;
                this.orbitAngle = angle;
            }

            // 物理属性
            this.ox = this.x; // 原始坐标记录
            this.oy = this.y;
            this.oz = this.z;
            
            this.size = Math.random() * 1.5 + 0.5;
            // 颜色随机微调
            this.r = config.colorBase.r + (Math.random() * 40 - 20);
            this.g = config.colorBase.g + (Math.random() * 40 - 20);
            this.b = config.colorBase.b + (Math.random() * 40 - 20);
            
            // 交互偏移量
            this.interactX = 0;
            this.interactY = 0;
            this.interactZ = 0;
        }

        update() {
            // 1. 基础物理运动 (开普勒轨道)
            if (this.type === 'ring') {
                this.orbitAngle += this.baseSpeed;
                this.ox = Math.cos(this.orbitAngle) * this.orbitRadius;
                this.oz = Math.sin(this.orbitAngle) * this.orbitRadius;
            } else {
                // 星球本体缓慢自转效果（绕Y轴）
                const cosRot = Math.cos(0.005);
                const sinRot = Math.sin(0.005);
                const x = this.ox * cosRot - this.oz * sinRot;
                const z = this.ox * sinRot + this.oz * cosRot;
                this.ox = x;
                this.oz = z;
            }

            // 2. 处理鼠标悬停交互 (开普勒引力捕获)
            // 如果鼠标悬停在按钮上，部分粒子被"吸"过去形成小光环
            if (state.hoverTarget) {
                // 简单的弹簧吸引逻辑，让粒子偏离原轨道
                const dx = (state.hoverTarget.x - width/2) * 2; // 放大偏移效果
                const dy = (state.hoverTarget.y - height/2) * 2;
                
                // 只有一部分粒子响应，制造层次感
                if (Math.random() > 0.6) {
                    this.interactX += (dx - this.interactX) * 0.05;
                    this.interactY += (dy - this.interactY) * 0.05;
                }
            } else {
                // 复位
                this.interactX *= 0.95;
                this.interactY *= 0.95;
            }

            // 3. 混沌效应 (Chaos Mode)
            // 当缩放过大，粒子开始布朗运动
            let chaosX = 0, chaosY = 0, chaosZ = 0;
            if (state.zoom > config.chaosThreshold) {
                const intensity = (state.zoom - config.chaosThreshold) * 5;
                chaosX = (Math.random() - 0.5) * intensity * 20;
                chaosY = (Math.random() - 0.5) * intensity * 20;
                chaosZ = (Math.random() - 0.5) * intensity * 20;
            }

            // 4. 3D 旋转变换 (响应鼠标拖拽/位置)
            // 结合原始坐标 + 交互偏移 + 混沌偏移
            let x = this.ox + this.interactX + chaosX;
            let y = this.oy + this.interactY + chaosY;
            let z = this.oz + this.interactZ + chaosZ;

            // 绕X轴旋转
            const cosX = Math.cos(state.rotationX);
            const sinX = Math.sin(state.rotationX);
            const y1 = y * cosX - z * sinX;
            const z1 = y * sinX + z * cosX;

            // 绕Y轴旋转 (由鼠标X轴位置控制)
            const cosY = Math.cos(state.rotationY);
            const sinY = Math.sin(state.rotationY);
            const x2 = x * cosY - z1 * sinY;
            const z2 = x * sinY + z1 * cosY;

            // 5. 投影 (3D -> 2D)
            // z2 越大越远。我们需要把 z 移到摄像机前方
            const dist = config.focalLength + z2;
            
            // 视锥裁剪：太近或太远的不绘制
            if (dist < 0) return;

            const scale = config.focalLength / dist * state.zoom;
            
            this.projX = x2 * scale + width / 2;
            this.projY = y1 * scale + height / 2;
            this.projScale = scale;
            this.projZ = z2; // 用于排序
            
            // 6. 渲染
            this.draw(ctx);
        }

        draw(ctx) {
            // 亮度计算：物理规律 (距离平方反比)
            // 另外叠加 Zoom 带来的亮度增强
            let alpha = 1.5 / (this.projZ / 300 + 1.5); 
            
            // 临场感增强：当由于放大导致粒子极度接近屏幕时，亮度爆发
            if (state.zoom > 2) {
                alpha *= (state.zoom / 1.5);
            }
            
            // 限制 Alpha 范围
            alpha = Math.min(1, Math.max(0, alpha));

            ctx.beginPath();
            ctx.fillStyle = `rgba(${this.r}, ${this.g}, ${this.b}, ${alpha})`;
            
            // 粒子大小随距离变化
            let renderSize = this.size * this.projScale;
            
            // 混沌模式下的高频噪点绘制（画成不规则形状或线段模拟运动模糊）
            if (state.zoom > config.chaosThreshold) {
                ctx.rect(this.projX, this.projY, renderSize * Math.random()*2, renderSize);
            } else {
                ctx.arc(this.projX, this.projY, renderSize, 0, Math.PI * 2);
            }
            ctx.fill();
        }
    }

    // 初始化粒子群
    function initParticles() {
        particles = [];
        // 40% 属于本体，60% 属于光环
        for (let i = 0; i < config.particleCount; i++) {
            const type = i < config.particleCount * 0.4 ? 'planet' : 'ring';
            particles.push(new Particle(type));
        }
    }

    // 交互事件监听
    
    // 1. 鼠标滚轮缩放
    canvas.addEventListener('wheel', e => {
        e.preventDefault();
        const delta = e.deltaY * -0.001;
        state.zoom += delta;
        // 限制缩放范围
        state.zoom = Math.min(Math.max(0.2, state.zoom), 5.0);
    }, { passive: false });

    // 2. 鼠标移动控制旋转
    document.addEventListener('mousemove', e => {
        state.mouseX = e.clientX;
        state.mouseY = e.clientY;
        
        // 将鼠标坐标映射到旋转角度
        state.rotationY = (state.mouseX - width / 2) * 0.002;
        state.rotationX = (state.mouseY - height / 2) * 0.002 + 0.5; // +0.5 保持一点初始倾斜
        
        // 检测是否悬浮在交互元素上 (实现要求9)
        let hovering = false;
        interactiveElements.each(function() {
            const rect = this.getBoundingClientRect();
            // 简单的矩形碰撞检测
            if (state.mouseX >= rect.left && state.mouseX <= rect.right &&
                state.mouseY >= rect.top && state.mouseY <= rect.bottom) {
                
                state.hoverTarget = {
                    x: rect.left + rect.width / 2,
                    y: rect.top + rect.height / 2
                };
                hovering = true;
                return false; // break loop
            }
        });
        
        if (!hovering) state.hoverTarget = null;
    });

    // 3. 全屏控制
    $('#fs-btn').on('click', function() {
        const doc = window.document;
        const docEl = doc.documentElement;
        
        const requestFullScreen = docEl.requestFullscreen || docEl.mozRequestFullScreen || docEl.webkitRequestFullScreen || docEl.msRequestFullscreen;
        const cancelFullScreen = doc.exitFullscreen || doc.mozCancelFullScreen || doc.webkitExitFullscreen || doc.msExitFullscreen;
        
        if(!doc.fullscreenElement && !doc.mozFullScreenElement && !doc.webkitFullscreenElement && !doc.msFullscreenElement) {
            requestFullScreen.call(docEl);
        } else {
            cancelFullScreen.call(doc);
        }
    });

    // 动画循环
    function loop() {
        // 使用半透明清空画布，形成轻微的拖尾效果，增加速度感
        ctx.fillStyle = 'rgba(18, 25, 69, 0.2)'; // 对应CSS背景色，略带透明
        ctx.fillRect(0, 0, width, height);

        // 深度排序 (Painter's Algorithm)：确保远处的粒子被近处的遮挡
        particles.sort((a, b) => b.projZ - a.projZ);

        particles.forEach(p => p.update());

        requestAnimationFrame(loop);
    }

    initParticles();
    loop();
});
