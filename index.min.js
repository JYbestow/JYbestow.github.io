// 动画兼容
window.requestAnimFrame = (function() {
    return window.requestAnimationFrame || function(callback) {
        window.setTimeout(callback, 1000 / 60);
    };
})();

$(function() {
    const canvas = document.getElementById('startrack');
    const ctx = canvas.getContext('2d');
    
    let cw, ch;
    // 鼠标位置 (用于视差和交互)
    let mx = 0, my = 0;
    
    // 初始化 Canvas 尺寸
    function resize() {
        cw = canvas.width = window.innerWidth;
        ch = canvas.height = window.innerHeight;
    }
    resize();
    window.addEventListener('resize', resize);

    // 追踪鼠标
    document.addEventListener('mousemove', (e) => {
        mx = (e.clientX - cw / 2) / cw;
        my = (e.clientY - ch / 2) / ch;
        
        // 简单的 3D 卡片倾斜逻辑 (保留自上一版，增强体验)
        const card = document.getElementById('tilt-card');
        if(card) {
            card.style.transform = `perspective(1000px) rotateX(${-my * 10}deg) rotateY(${mx * 10}deg) translateY(-15px)`; // translateY 保留浮动
        }
    });

    document.addEventListener('mouseleave', () => {
        const card = document.getElementById('tilt-card');
        if(card) card.style.transform = `perspective(1000px) rotateX(0) rotateY(0)`;
    });

    /**
     * 星星类 - 符合开普勒运动
     */
    class Star {
        constructor() {
            this.reset();
        }

        reset() {
            // 随机半径，避开极中心的黑洞区域
            this.r = Math.random() * Math.max(cw, ch) * 0.8 + 50; 
            this.angle = Math.random() * Math.PI * 2;
            
            // 开普勒第三定律：角速度 omega ∝ r^(-3/2)
            // 调整系数 3000 是为了让速度在视觉上合理
            this.omega = 3000 / Math.pow(this.r, 1.5);
            
            // 随机大小
            this.size = Math.random() * 2;
            
            // 颜色：内圈偏蓝/亮（高温），外圈偏红/暗（低温/红移）
            const colorVal = Math.min(255, Math.floor(20000 / this.r)); 
            this.color = `rgba(${colorVal}, ${colorVal * 0.8}, 255, ${Math.random() * 0.5 + 0.5})`;
        }

        update() {
            // 更新角度
            this.angle += this.omega;
            
            // 简单的边界检查，防止溢出虽然圆周运动不需要
            if (this.angle > Math.PI * 2) this.angle -= Math.PI * 2;
        }

        draw() {
            // 极坐标转笛卡尔坐标，并加上中心偏移
            // 增加一点点鼠标视差 (mx * 20)
            const x = cw / 2 + Math.cos(this.angle) * this.r - mx * 20;
            const y = ch / 2 + Math.sin(this.angle) * this.r - my * 20;

            // 绘制星星
            ctx.beginPath();
            ctx.arc(x, y, this.size, 0, Math.PI * 2);
            ctx.fillStyle = this.color;
            ctx.fill();
        }
    }

    /**
     * 爆炸粒子类 - 用于点击反馈
     */
    class Particle {
        constructor(x, y) {
            this.x = x;
            this.y = y;
            const angle = Math.random() * Math.PI * 2;
            const speed = Math.random() * 5 + 2;
            this.vx = Math.cos(angle) * speed;
            this.vy = Math.sin(angle) * speed;
            this.life = 1.0;
            this.color = `rgba(255, ${Math.random()*100 + 150}, 245,`; // 粉色系
        }
        update() {
            this.x += this.vx;
            this.y += this.vy;
            this.vy += 0.2; // 重力
            this.life -= 0.02; // 寿命衰减
        }
        draw() {
            ctx.beginPath();
            ctx.arc(this.x, this.y, 2 * this.life, 0, Math.PI * 2);
            ctx.fillStyle = this.color + this.life + ")";
            ctx.fill();
        }
    }

    const stars = [];
    const particles = [];
    const STAR_COUNT = 1500; // 星星数量

    // 初始化星星
    for (let i = 0; i < STAR_COUNT; i++) {
        stars.push(new Star());
    }

    // 点击事件：生成爆炸
    document.addEventListener('mousedown', (e) => {
        // 在鼠标位置生成一堆粒子
        for(let i=0; i<20; i++) {
            particles.push(new Particle(e.clientX, e.clientY));
        }
    });

    // 动画主循环
    function loop() {
        // 使用半透明填充来实现长拖尾效果
        // 颜色越深，拖尾越长；0.1 表示每一帧只覆盖 10% 的旧图像
        ctx.fillStyle = 'rgba(11, 16, 38, 0.2)'; 
        ctx.fillRect(0, 0, cw, ch);

        // 开启颜色减淡混合模式，让重叠的星星发光
        ctx.globalCompositeOperation = 'lighter';

        // 绘制星星
        stars.forEach(star => {
            star.update();
            star.draw();
        });

        // 绘制爆炸粒子
        for (let i = particles.length - 1; i >= 0; i--) {
            const p = particles[i];
            p.update();
            p.draw();
            if (p.life <= 0) {
                particles.splice(i, 1);
            }
        }

        // 恢复默认混合模式
        ctx.globalCompositeOperation = 'source-over';

        requestAnimFrame(loop);
    }

    loop();
});
